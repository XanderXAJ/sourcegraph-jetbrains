package hackathon;// AUTO-GENERATED FILE. DO NOT MODIFY.
//
// This class was automatically generated by Apollo GraphQL plugin from the GraphQL queries it found.
// It should not be modified by hand.
//

import com.apollographql.apollo.api.*;
import com.apollographql.apollo.api.internal.*;
import okio.Buffer;
import okio.BufferedSource;
import okio.ByteString;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import type.CustomType;

import java.io.IOException;
import java.util.*;

public final class SearchQuery implements Query<SearchQuery.Data, SearchQuery.Data, SearchQuery.Variables> {
  public static final String OPERATION_ID = "c646981209ba8a576abdd01905efe389e2ae916a9ff1f81e9e54beb73af91f58";

  public static final String QUERY_DOCUMENT = QueryDocumentMinifier.minify(
    "query Search($query: String!) {\n"
        + "  search(query: $query, version: V2, patternType: literal) {\n"
        + "    __typename\n"
        + "    results {\n"
        + "      __typename\n"
        + "      limitHit\n"
        + "      cloning {\n"
        + "        __typename\n"
        + "        name\n"
        + "      }\n"
        + "      missing {\n"
        + "        __typename\n"
        + "        name\n"
        + "      }\n"
        + "      timedout {\n"
        + "        __typename\n"
        + "        name\n"
        + "      }\n"
        + "      matchCount\n"
        + "      results {\n"
        + "        __typename\n"
        + "        ... on FileMatch {\n"
        + "          repository {\n"
        + "            __typename\n"
        + "            id\n"
        + "            name\n"
        + "          }\n"
        + "          file {\n"
        + "            __typename\n"
        + "            name\n"
        + "            path\n"
        + "            isDirectory\n"
        + "            content\n"
        + "          }\n"
        + "          lineMatches {\n"
        + "            __typename\n"
        + "            offsetAndLengths\n"
        + "            preview\n"
        + "            lineNumber\n"
        + "          }\n"
        + "          symbols {\n"
        + "            __typename\n"
        + "            name\n"
        + "          }\n"
        + "        }\n"
        + "        ... on Repository {\n"
        + "          id\n"
        + "          name\n"
        + "        }\n"
        + "      }\n"
        + "    }\n"
        + "  }\n"
        + "}"
  );

  public static final OperationName OPERATION_NAME = new OperationName() {
    @Override
    public String name() {
      return "Search";
    }
  };

  private final Variables variables;

  public SearchQuery(@NotNull String query) {
    Utils.checkNotNull(query, "query == null");
    variables = new Variables(query);
  }

  @Override
  public String operationId() {
    return OPERATION_ID;
  }

  @Override
  public String queryDocument() {
    return QUERY_DOCUMENT;
  }

  @Override
  public Data wrapData(Data data) {
    return data;
  }

  @Override
  public Variables variables() {
    return variables;
  }

  @Override
  public ResponseFieldMapper<Data> responseFieldMapper() {
    return new Data.Mapper();
  }

  public static Builder builder() {
    return new Builder();
  }

  @Override
  public OperationName name() {
    return OPERATION_NAME;
  }

  @Override
  @NotNull
  public Response<Data> parse(@NotNull final BufferedSource source,
                              @NotNull final ScalarTypeAdapters scalarTypeAdapters) throws IOException {
    return SimpleOperationResponseParser.parse(source, this, scalarTypeAdapters);
  }

  @Override
  @NotNull
  public Response<Data> parse(@NotNull final ByteString byteString,
                              @NotNull final ScalarTypeAdapters scalarTypeAdapters) throws IOException {
    return parse(new Buffer().write(byteString), scalarTypeAdapters);
  }

  @Override
  @NotNull
  public Response<Data> parse(@NotNull final BufferedSource source) throws IOException {
    return parse(source, ScalarTypeAdapters.DEFAULT);
  }

  @Override
  @NotNull
  public Response<Data> parse(@NotNull final ByteString byteString) throws IOException {
    return parse(byteString, ScalarTypeAdapters.DEFAULT);
  }

  @Override
  @NotNull
  public ByteString composeRequestBody(@NotNull final ScalarTypeAdapters scalarTypeAdapters) {
    return OperationRequestBodyComposer.compose(this, false, true, scalarTypeAdapters);
  }

  @NotNull
  @Override
  public ByteString composeRequestBody() {
    return OperationRequestBodyComposer.compose(this, false, true, ScalarTypeAdapters.DEFAULT);
  }

  @Override
  @NotNull
  public ByteString composeRequestBody(final boolean autoPersistQueries,
      final boolean withQueryDocument, @NotNull final ScalarTypeAdapters scalarTypeAdapters) {
    return OperationRequestBodyComposer.compose(this, autoPersistQueries, withQueryDocument, scalarTypeAdapters);
  }

  public static final class Builder {
    private @NotNull String query;

    Builder() {
    }

    public Builder query(@NotNull String query) {
      this.query = query;
      return this;
    }

    public SearchQuery build() {
      Utils.checkNotNull(query, "query == null");
      return new SearchQuery(query);
    }
  }

  public static final class Variables extends Operation.Variables {
    private final @NotNull String query;

    private final transient Map<String, Object> valueMap = new LinkedHashMap<>();

    Variables(@NotNull String query) {
      this.query = query;
      this.valueMap.put("query", query);
    }

    public @NotNull String query() {
      return query;
    }

    @Override
    public Map<String, Object> valueMap() {
      return Collections.unmodifiableMap(valueMap);
    }

    @Override
    public InputFieldMarshaller marshaller() {
      return new InputFieldMarshaller() {
        @Override
        public void marshal(InputFieldWriter writer) throws IOException {
          writer.writeString("query", query);
        }
      };
    }
  }

  /**
   * Data from the response after executing this GraphQL operation
   */
  public static class Data implements Operation.Data {
    static final ResponseField[] $responseFields = {
      ResponseField.forObject("search", "search", new UnmodifiableMapBuilder<String, Object>(3)
      .put("query", new UnmodifiableMapBuilder<String, Object>(2)
        .put("kind", "Variable")
        .put("variableName", "query")
        .build())
      .put("version", "V2")
      .put("patternType", "literal")
      .build(), true, Collections.<ResponseField.Condition>emptyList())
    };

    final @Nullable Search search;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public Data(@Nullable Search search) {
      this.search = search;
    }

    /**
     * Runs a search.
     */
    public @Nullable Search search() {
      return this.search;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeObject($responseFields[0], search != null ? search.marshaller() : null);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Data{"
          + "search=" + search
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Data) {
        Data that = (Data) o;
        return ((this.search == null) ? (that.search == null) : this.search.equals(that.search));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= (search == null) ? 0 : search.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<Data> {
      final Search.Mapper searchFieldMapper = new Search.Mapper();

      @Override
      public Data map(ResponseReader reader) {
        final Search search = reader.readObject($responseFields[0], new ResponseReader.ObjectReader<Search>() {
          @Override
          public Search read(ResponseReader reader) {
            return searchFieldMapper.map(reader);
          }
        });
        return new Data(search);
      }
    }
  }

  /**
   * A search.
   */
  public static class Search {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forObject("results", "results", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull Results results;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public Search(@NotNull String __typename, @NotNull Results results) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.results = Utils.checkNotNull(results, "results == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * The results.
     */
    public @NotNull Results results() {
      return this.results;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeObject($responseFields[1], results.marshaller());
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Search{"
          + "__typename=" + __typename + ", "
          + "results=" + results
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Search) {
        Search that = (Search) o;
        return this.__typename.equals(that.__typename)
         && this.results.equals(that.results);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= results.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<Search> {
      final Results.Mapper resultsFieldMapper = new Results.Mapper();

      @Override
      public Search map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final Results results = reader.readObject($responseFields[1], new ResponseReader.ObjectReader<Results>() {
          @Override
          public Results read(ResponseReader reader) {
            return resultsFieldMapper.map(reader);
          }
        });
        return new Search(__typename, results);
      }
    }
  }

  /**
   * Search results.
   */
  public static class Results {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forBoolean("limitHit", "limitHit", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forList("cloning", "cloning", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forList("missing", "missing", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forList("timedout", "timedout", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forInt("matchCount", "matchCount", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forList("results", "results", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final boolean limitHit;

    final @NotNull List<Cloning> cloning;

    final @NotNull List<Missing> missing;

    final @NotNull List<Timedout> timedout;

    final int matchCount;

    final @NotNull List<Result> results;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public Results(@NotNull String __typename, boolean limitHit, @NotNull List<Cloning> cloning,
        @NotNull List<Missing> missing, @NotNull List<Timedout> timedout, int matchCount,
        @NotNull List<Result> results) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.limitHit = limitHit;
      this.cloning = Utils.checkNotNull(cloning, "cloning == null");
      this.missing = Utils.checkNotNull(missing, "missing == null");
      this.timedout = Utils.checkNotNull(timedout, "timedout == null");
      this.matchCount = matchCount;
      this.results = Utils.checkNotNull(results, "results == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * Whether or not the results limit was hit.
     * In paginated requests, this field is always false. Use 'pageInfo.hasNextPage' instead.
     */
    public boolean limitHit() {
      return this.limitHit;
    }

    /**
     * Repositories that are busy cloning onto gitserver.
     * In paginated search requests, some repositories may be cloning. These are reported here
     * and you may choose to retry the paginated request with the same cursor after they have
     * cloned OR you may simply continue making further paginated requests and choose to skip
     * the cloning repositories.
     */
    public @NotNull List<Cloning> cloning() {
      return this.cloning;
    }

    /**
     * Repositories or commits that do not exist.
     * In paginated search requests, some repositories may be missing (e.g. if Sourcegraph is
     * aware of them but is temporarily unable to serve them). These are reported here and you
     * may choose to retry the paginated request with the same cursor and they may no longer be
     * missing OR you may simply continue making further paginated requests and choose to skip
     * the missing repositories.
     */
    public @NotNull List<Missing> missing() {
      return this.missing;
    }

    /**
     * Repositories or commits which we did not manage to search in time. Trying
     * again usually will work.
     * In paginated search requests, this field is not relevant.
     */
    public @NotNull List<Timedout> timedout() {
      return this.timedout;
    }

    /**
     * The total number of matches returned by this search. This is different
     * than the length of the results array in that e.g. a single results array
     * entry may contain multiple matches. For example, the results array may
     * contain two file matches and this field would report 6 ("3 line matches
     * per file") while the length of the results array would report 3
     * ("3 FileMatch results").
     * Typically, 'approximateResultCount', not this field, is shown to users.
     */
    public int matchCount() {
      return this.matchCount;
    }

    /**
     * The results. Inside each SearchResult there may be multiple matches, e.g.
     * a FileMatch may contain multiple line matches.
     */
    public @NotNull List<Result> results() {
      return this.results;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeBoolean($responseFields[1], limitHit);
          writer.writeList($responseFields[2], cloning, new ResponseWriter.ListWriter() {
            @Override
            public void write(List items, ResponseWriter.ListItemWriter listItemWriter) {
              for (Object item : items) {
                listItemWriter.writeObject(((Cloning) item).marshaller());
              }
            }
          });
          writer.writeList($responseFields[3], missing, new ResponseWriter.ListWriter() {
            @Override
            public void write(List items, ResponseWriter.ListItemWriter listItemWriter) {
              for (Object item : items) {
                listItemWriter.writeObject(((Missing) item).marshaller());
              }
            }
          });
          writer.writeList($responseFields[4], timedout, new ResponseWriter.ListWriter() {
            @Override
            public void write(List items, ResponseWriter.ListItemWriter listItemWriter) {
              for (Object item : items) {
                listItemWriter.writeObject(((Timedout) item).marshaller());
              }
            }
          });
          writer.writeInt($responseFields[5], matchCount);
          writer.writeList($responseFields[6], results, new ResponseWriter.ListWriter() {
            @Override
            public void write(List items, ResponseWriter.ListItemWriter listItemWriter) {
              for (Object item : items) {
                listItemWriter.writeObject(((Result) item).marshaller());
              }
            }
          });
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Results{"
          + "__typename=" + __typename + ", "
          + "limitHit=" + limitHit + ", "
          + "cloning=" + cloning + ", "
          + "missing=" + missing + ", "
          + "timedout=" + timedout + ", "
          + "matchCount=" + matchCount + ", "
          + "results=" + results
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Results) {
        Results that = (Results) o;
        return this.__typename.equals(that.__typename)
         && this.limitHit == that.limitHit
         && this.cloning.equals(that.cloning)
         && this.missing.equals(that.missing)
         && this.timedout.equals(that.timedout)
         && this.matchCount == that.matchCount
         && this.results.equals(that.results);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= Boolean.valueOf(limitHit).hashCode();
        h *= 1000003;
        h ^= cloning.hashCode();
        h *= 1000003;
        h ^= missing.hashCode();
        h *= 1000003;
        h ^= timedout.hashCode();
        h *= 1000003;
        h ^= matchCount;
        h *= 1000003;
        h ^= results.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<Results> {
      final Cloning.Mapper cloningFieldMapper = new Cloning.Mapper();

      final Missing.Mapper missingFieldMapper = new Missing.Mapper();

      final Timedout.Mapper timedoutFieldMapper = new Timedout.Mapper();

      final Result.Mapper resultFieldMapper = new Result.Mapper();

      @Override
      public Results map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final boolean limitHit = reader.readBoolean($responseFields[1]);
        final List<Cloning> cloning = reader.readList($responseFields[2], new ResponseReader.ListReader<Cloning>() {
          @Override
          public Cloning read(ResponseReader.ListItemReader listItemReader) {
            return listItemReader.readObject(new ResponseReader.ObjectReader<Cloning>() {
              @Override
              public Cloning read(ResponseReader reader) {
                return cloningFieldMapper.map(reader);
              }
            });
          }
        });
        final List<Missing> missing = reader.readList($responseFields[3], new ResponseReader.ListReader<Missing>() {
          @Override
          public Missing read(ResponseReader.ListItemReader listItemReader) {
            return listItemReader.readObject(new ResponseReader.ObjectReader<Missing>() {
              @Override
              public Missing read(ResponseReader reader) {
                return missingFieldMapper.map(reader);
              }
            });
          }
        });
        final List<Timedout> timedout = reader.readList($responseFields[4], new ResponseReader.ListReader<Timedout>() {
          @Override
          public Timedout read(ResponseReader.ListItemReader listItemReader) {
            return listItemReader.readObject(new ResponseReader.ObjectReader<Timedout>() {
              @Override
              public Timedout read(ResponseReader reader) {
                return timedoutFieldMapper.map(reader);
              }
            });
          }
        });
        final int matchCount = reader.readInt($responseFields[5]);
        final List<Result> results = reader.readList($responseFields[6], new ResponseReader.ListReader<Result>() {
          @Override
          public Result read(ResponseReader.ListItemReader listItemReader) {
            return listItemReader.readObject(new ResponseReader.ObjectReader<Result>() {
              @Override
              public Result read(ResponseReader reader) {
                return resultFieldMapper.map(reader);
              }
            });
          }
        });
        return new Results(__typename, limitHit, cloning, missing, timedout, matchCount, results);
      }
    }
  }

  /**
   * A repository is a Git source control repository that is mirrored from some origin code host.
   */
  public static class Cloning {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("name", "name", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull String name;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public Cloning(@NotNull String __typename, @NotNull String name) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.name = Utils.checkNotNull(name, "name == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * The repository's name, as a path with one or more components. It conventionally consists of
     * the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
     * Examples:
     * - github.com/foo/bar
     * - my-code-host.example.com/myrepo
     * - myrepo
     */
    public @NotNull String name() {
      return this.name;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeString($responseFields[1], name);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Cloning{"
          + "__typename=" + __typename + ", "
          + "name=" + name
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Cloning) {
        Cloning that = (Cloning) o;
        return this.__typename.equals(that.__typename)
         && this.name.equals(that.name);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= name.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<Cloning> {
      @Override
      public Cloning map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final String name = reader.readString($responseFields[1]);
        return new Cloning(__typename, name);
      }
    }
  }

  /**
   * A repository is a Git source control repository that is mirrored from some origin code host.
   */
  public static class Missing {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("name", "name", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull String name;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public Missing(@NotNull String __typename, @NotNull String name) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.name = Utils.checkNotNull(name, "name == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * The repository's name, as a path with one or more components. It conventionally consists of
     * the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
     * Examples:
     * - github.com/foo/bar
     * - my-code-host.example.com/myrepo
     * - myrepo
     */
    public @NotNull String name() {
      return this.name;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeString($responseFields[1], name);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Missing{"
          + "__typename=" + __typename + ", "
          + "name=" + name
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Missing) {
        Missing that = (Missing) o;
        return this.__typename.equals(that.__typename)
         && this.name.equals(that.name);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= name.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<Missing> {
      @Override
      public Missing map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final String name = reader.readString($responseFields[1]);
        return new Missing(__typename, name);
      }
    }
  }

  /**
   * A repository is a Git source control repository that is mirrored from some origin code host.
   */
  public static class Timedout {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("name", "name", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull String name;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public Timedout(@NotNull String __typename, @NotNull String name) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.name = Utils.checkNotNull(name, "name == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * The repository's name, as a path with one or more components. It conventionally consists of
     * the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
     * Examples:
     * - github.com/foo/bar
     * - my-code-host.example.com/myrepo
     * - myrepo
     */
    public @NotNull String name() {
      return this.name;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeString($responseFields[1], name);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Timedout{"
          + "__typename=" + __typename + ", "
          + "name=" + name
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Timedout) {
        Timedout that = (Timedout) o;
        return this.__typename.equals(that.__typename)
         && this.name.equals(that.name);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= name.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<Timedout> {
      @Override
      public Timedout map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final String name = reader.readString($responseFields[1]);
        return new Timedout(__typename, name);
      }
    }
  }

  /**
   * A search result.
   */
  public interface Result {
    @NotNull String __typename();

    ResponseFieldMarshaller marshaller();

    final class Mapper implements ResponseFieldMapper<Result> {
      static final ResponseField[] $responseFields = {
        ResponseField.forFragment("__typename", "__typename", Arrays.<ResponseField.Condition>asList(
          ResponseField.Condition.typeCondition(new String[] {"FileMatch"})
        )),
        ResponseField.forFragment("__typename", "__typename", Arrays.<ResponseField.Condition>asList(
          ResponseField.Condition.typeCondition(new String[] {"Repository"})
        ))
      };

      final AsFileMatch.Mapper asFileMatchFieldMapper = new AsFileMatch.Mapper();

      final AsRepository.Mapper asRepositoryFieldMapper = new AsRepository.Mapper();

      final AsSearchResult.Mapper asSearchResultFieldMapper = new AsSearchResult.Mapper();

      @Override
      public Result map(ResponseReader reader) {
        final AsFileMatch asFileMatch = reader.readFragment($responseFields[0], new ResponseReader.ObjectReader<AsFileMatch>() {
          @Override
          public AsFileMatch read(ResponseReader reader) {
            return asFileMatchFieldMapper.map(reader);
          }
        });
        if (asFileMatch != null) {
          return asFileMatch;
        }
        final AsRepository asRepository = reader.readFragment($responseFields[1], new ResponseReader.ObjectReader<AsRepository>() {
          @Override
          public AsRepository read(ResponseReader reader) {
            return asRepositoryFieldMapper.map(reader);
          }
        });
        if (asRepository != null) {
          return asRepository;
        }
        return asSearchResultFieldMapper.map(reader);
      }
    }
  }

  /**
   * A file match.
   */
  public static class AsFileMatch implements Result {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forObject("repository", "repository", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forObject("file", "file", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forList("lineMatches", "lineMatches", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forList("symbols", "symbols", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull Repository repository;

    final @NotNull File file;

    final @NotNull List<LineMatch> lineMatches;

    final @NotNull List<Symbol> symbols;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public AsFileMatch(@NotNull String __typename, @NotNull Repository repository,
        @NotNull File file, @NotNull List<LineMatch> lineMatches, @NotNull List<Symbol> symbols) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.repository = Utils.checkNotNull(repository, "repository == null");
      this.file = Utils.checkNotNull(file, "file == null");
      this.lineMatches = Utils.checkNotNull(lineMatches, "lineMatches == null");
      this.symbols = Utils.checkNotNull(symbols, "symbols == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * The repository containing the file match.
     */
    public @NotNull Repository repository() {
      return this.repository;
    }

    /**
     * The file containing the match.
     * KNOWN ISSUE: This file's "commit" field contains incomplete data.
     * KNOWN ISSUE: This field's type should be File! not GitBlob!.
     */
    public @NotNull File file() {
      return this.file;
    }

    /**
     * The line matches.
     */
    public @NotNull List<LineMatch> lineMatches() {
      return this.lineMatches;
    }

    /**
     * The symbols found in this file that match the query.
     */
    public @NotNull List<Symbol> symbols() {
      return this.symbols;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeObject($responseFields[1], repository.marshaller());
          writer.writeObject($responseFields[2], file.marshaller());
          writer.writeList($responseFields[3], lineMatches, new ResponseWriter.ListWriter() {
            @Override
            public void write(List items, ResponseWriter.ListItemWriter listItemWriter) {
              for (Object item : items) {
                listItemWriter.writeObject(((LineMatch) item).marshaller());
              }
            }
          });
          writer.writeList($responseFields[4], symbols, new ResponseWriter.ListWriter() {
            @Override
            public void write(List items, ResponseWriter.ListItemWriter listItemWriter) {
              for (Object item : items) {
                listItemWriter.writeObject(((Symbol) item).marshaller());
              }
            }
          });
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "AsFileMatch{"
          + "__typename=" + __typename + ", "
          + "repository=" + repository + ", "
          + "file=" + file + ", "
          + "lineMatches=" + lineMatches + ", "
          + "symbols=" + symbols
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof AsFileMatch) {
        AsFileMatch that = (AsFileMatch) o;
        return this.__typename.equals(that.__typename)
         && this.repository.equals(that.repository)
         && this.file.equals(that.file)
         && this.lineMatches.equals(that.lineMatches)
         && this.symbols.equals(that.symbols);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= repository.hashCode();
        h *= 1000003;
        h ^= file.hashCode();
        h *= 1000003;
        h ^= lineMatches.hashCode();
        h *= 1000003;
        h ^= symbols.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<AsFileMatch> {
      final Repository.Mapper repositoryFieldMapper = new Repository.Mapper();

      final File.Mapper fileFieldMapper = new File.Mapper();

      final LineMatch.Mapper lineMatchFieldMapper = new LineMatch.Mapper();

      final Symbol.Mapper symbolFieldMapper = new Symbol.Mapper();

      @Override
      public AsFileMatch map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final Repository repository = reader.readObject($responseFields[1], new ResponseReader.ObjectReader<Repository>() {
          @Override
          public Repository read(ResponseReader reader) {
            return repositoryFieldMapper.map(reader);
          }
        });
        final File file = reader.readObject($responseFields[2], new ResponseReader.ObjectReader<File>() {
          @Override
          public File read(ResponseReader reader) {
            return fileFieldMapper.map(reader);
          }
        });
        final List<LineMatch> lineMatches = reader.readList($responseFields[3], new ResponseReader.ListReader<LineMatch>() {
          @Override
          public LineMatch read(ResponseReader.ListItemReader listItemReader) {
            return listItemReader.readObject(new ResponseReader.ObjectReader<LineMatch>() {
              @Override
              public LineMatch read(ResponseReader reader) {
                return lineMatchFieldMapper.map(reader);
              }
            });
          }
        });
        final List<Symbol> symbols = reader.readList($responseFields[4], new ResponseReader.ListReader<Symbol>() {
          @Override
          public Symbol read(ResponseReader.ListItemReader listItemReader) {
            return listItemReader.readObject(new ResponseReader.ObjectReader<Symbol>() {
              @Override
              public Symbol read(ResponseReader reader) {
                return symbolFieldMapper.map(reader);
              }
            });
          }
        });
        return new AsFileMatch(__typename, repository, file, lineMatches, symbols);
      }
    }
  }

  /**
   * A repository is a Git source control repository that is mirrored from some origin code host.
   */
  public static class Repository {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forCustomType("id", "id", null, false, CustomType.ID, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("name", "name", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull String id;

    final @NotNull String name;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public Repository(@NotNull String __typename, @NotNull String id, @NotNull String name) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.id = Utils.checkNotNull(id, "id == null");
      this.name = Utils.checkNotNull(name, "name == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * The repository's unique ID.
     */
    public @NotNull String id() {
      return this.id;
    }

    /**
     * The repository's name, as a path with one or more components. It conventionally consists of
     * the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
     * Examples:
     * - github.com/foo/bar
     * - my-code-host.example.com/myrepo
     * - myrepo
     */
    public @NotNull String name() {
      return this.name;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeCustom((ResponseField.CustomTypeField) $responseFields[1], id);
          writer.writeString($responseFields[2], name);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Repository{"
          + "__typename=" + __typename + ", "
          + "id=" + id + ", "
          + "name=" + name
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Repository) {
        Repository that = (Repository) o;
        return this.__typename.equals(that.__typename)
         && this.id.equals(that.id)
         && this.name.equals(that.name);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= id.hashCode();
        h *= 1000003;
        h ^= name.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<Repository> {
      @Override
      public Repository map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final String id = reader.readCustomType((ResponseField.CustomTypeField) $responseFields[1]);
        final String name = reader.readString($responseFields[2]);
        return new Repository(__typename, id, name);
      }
    }
  }

  /**
   * A Git blob in a repository.
   */
  public static class File {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("name", "name", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("path", "path", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forBoolean("isDirectory", "isDirectory", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("content", "content", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull String name;

    final @NotNull String path;

    final boolean isDirectory;

    final @NotNull String content;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public File(@NotNull String __typename, @NotNull String name, @NotNull String path,
        boolean isDirectory, @NotNull String content) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.name = Utils.checkNotNull(name, "name == null");
      this.path = Utils.checkNotNull(path, "path == null");
      this.isDirectory = isDirectory;
      this.content = Utils.checkNotNull(content, "content == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * The base name (i.e., file name only) of this blob's path.
     */
    public @NotNull String name() {
      return this.name;
    }

    /**
     * The full path (relative to the repository root) of this blob.
     */
    public @NotNull String path() {
      return this.path;
    }

    /**
     * False because this is a blob (file), not a directory.
     */
    public boolean isDirectory() {
      return this.isDirectory;
    }

    /**
     * The content of this blob.
     */
    public @NotNull String content() {
      return this.content;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeString($responseFields[1], name);
          writer.writeString($responseFields[2], path);
          writer.writeBoolean($responseFields[3], isDirectory);
          writer.writeString($responseFields[4], content);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "File{"
          + "__typename=" + __typename + ", "
          + "name=" + name + ", "
          + "path=" + path + ", "
          + "isDirectory=" + isDirectory + ", "
          + "content=" + content
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof File) {
        File that = (File) o;
        return this.__typename.equals(that.__typename)
         && this.name.equals(that.name)
         && this.path.equals(that.path)
         && this.isDirectory == that.isDirectory
         && this.content.equals(that.content);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= name.hashCode();
        h *= 1000003;
        h ^= path.hashCode();
        h *= 1000003;
        h ^= Boolean.valueOf(isDirectory).hashCode();
        h *= 1000003;
        h ^= content.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<File> {
      @Override
      public File map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final String name = reader.readString($responseFields[1]);
        final String path = reader.readString($responseFields[2]);
        final boolean isDirectory = reader.readBoolean($responseFields[3]);
        final String content = reader.readString($responseFields[4]);
        return new File(__typename, name, path, isDirectory, content);
      }
    }
  }

  /**
   * A line match.
   */
  public static class LineMatch {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forList("offsetAndLengths", "offsetAndLengths", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("preview", "preview", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forInt("lineNumber", "lineNumber", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull List<List<Integer>> offsetAndLengths;

    final @NotNull String preview;

    final int lineNumber;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public LineMatch(@NotNull String __typename, @NotNull List<List<Integer>> offsetAndLengths,
        @NotNull String preview, int lineNumber) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.offsetAndLengths = Utils.checkNotNull(offsetAndLengths, "offsetAndLengths == null");
      this.preview = Utils.checkNotNull(preview, "preview == null");
      this.lineNumber = lineNumber;
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * Tuples of [offset, length] measured in characters (not bytes).
     */
    public @NotNull List<List<Integer>> offsetAndLengths() {
      return this.offsetAndLengths;
    }

    /**
     * The preview.
     */
    public @NotNull String preview() {
      return this.preview;
    }

    /**
     * The line number. 0-based. The first line will have lineNumber 0. Note: A
     * UI will normally display line numbers 1-based.
     */
    public int lineNumber() {
      return this.lineNumber;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeList($responseFields[1], offsetAndLengths, new ResponseWriter.ListWriter() {
            @Override
            public void write(List items, ResponseWriter.ListItemWriter listItemWriter) {
              for (Object item : items) {
                listItemWriter.writeList((List) item, new ResponseWriter.ListWriter() {
                  @Override
                  public void write(List items, ResponseWriter.ListItemWriter listItemWriter) {
                    for (Object item : items) {
                      listItemWriter.writeInt((Integer) item);
                    }
                  }
                });
              }
            }
          });
          writer.writeString($responseFields[2], preview);
          writer.writeInt($responseFields[3], lineNumber);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "LineMatch{"
          + "__typename=" + __typename + ", "
          + "offsetAndLengths=" + offsetAndLengths + ", "
          + "preview=" + preview + ", "
          + "lineNumber=" + lineNumber
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof LineMatch) {
        LineMatch that = (LineMatch) o;
        return this.__typename.equals(that.__typename)
         && this.offsetAndLengths.equals(that.offsetAndLengths)
         && this.preview.equals(that.preview)
         && this.lineNumber == that.lineNumber;
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= offsetAndLengths.hashCode();
        h *= 1000003;
        h ^= preview.hashCode();
        h *= 1000003;
        h ^= lineNumber;
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<LineMatch> {
      @Override
      public LineMatch map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final List<List<Integer>> offsetAndLengths = reader.readList($responseFields[1], new ResponseReader.ListReader<List<Integer>>() {
          @Override
          public List<Integer> read(ResponseReader.ListItemReader listItemReader) {
            return listItemReader.readList(new ResponseReader.ListReader<Integer>() {
              @Override
              public Integer read(ResponseReader.ListItemReader listItemReader) {
                return listItemReader.readInt();
              }
            });
          }
        });
        final String preview = reader.readString($responseFields[2]);
        final int lineNumber = reader.readInt($responseFields[3]);
        return new LineMatch(__typename, offsetAndLengths, preview, lineNumber);
      }
    }
  }

  /**
   * A code symbol (e.g., a function, variable, type, class, etc.).
   * It is derived from DocumentSymbol as defined in the Language Server Protocol (see https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_documentSymbol).
   */
  public static class Symbol {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("name", "name", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull String name;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public Symbol(@NotNull String __typename, @NotNull String name) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.name = Utils.checkNotNull(name, "name == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * The name of the symbol.
     */
    public @NotNull String name() {
      return this.name;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeString($responseFields[1], name);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Symbol{"
          + "__typename=" + __typename + ", "
          + "name=" + name
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Symbol) {
        Symbol that = (Symbol) o;
        return this.__typename.equals(that.__typename)
         && this.name.equals(that.name);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= name.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<Symbol> {
      @Override
      public Symbol map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final String name = reader.readString($responseFields[1]);
        return new Symbol(__typename, name);
      }
    }
  }

  /**
   * A repository is a Git source control repository that is mirrored from some origin code host.
   */
  public static class AsRepository implements Result {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forCustomType("id", "id", null, false, CustomType.ID, Collections.<ResponseField.Condition>emptyList()),
      ResponseField.forString("name", "name", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    final @NotNull String id;

    final @NotNull String name;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public AsRepository(@NotNull String __typename, @NotNull String id, @NotNull String name) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
      this.id = Utils.checkNotNull(id, "id == null");
      this.name = Utils.checkNotNull(name, "name == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    /**
     * The repository's unique ID.
     */
    public @NotNull String id() {
      return this.id;
    }

    /**
     * The repository's name, as a path with one or more components. It conventionally consists of
     * the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
     * Examples:
     * - github.com/foo/bar
     * - my-code-host.example.com/myrepo
     * - myrepo
     */
    public @NotNull String name() {
      return this.name;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
          writer.writeCustom((ResponseField.CustomTypeField) $responseFields[1], id);
          writer.writeString($responseFields[2], name);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "AsRepository{"
          + "__typename=" + __typename + ", "
          + "id=" + id + ", "
          + "name=" + name
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof AsRepository) {
        AsRepository that = (AsRepository) o;
        return this.__typename.equals(that.__typename)
         && this.id.equals(that.id)
         && this.name.equals(that.name);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        h *= 1000003;
        h ^= id.hashCode();
        h *= 1000003;
        h ^= name.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<AsRepository> {
      @Override
      public AsRepository map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        final String id = reader.readCustomType((ResponseField.CustomTypeField) $responseFields[1]);
        final String name = reader.readString($responseFields[2]);
        return new AsRepository(__typename, id, name);
      }
    }
  }

  /**
   * A search result.
   */
  public static class AsSearchResult implements Result {
    static final ResponseField[] $responseFields = {
      ResponseField.forString("__typename", "__typename", null, false, Collections.<ResponseField.Condition>emptyList())
    };

    final @NotNull String __typename;

    private transient volatile String $toString;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    public AsSearchResult(@NotNull String __typename) {
      this.__typename = Utils.checkNotNull(__typename, "__typename == null");
    }

    public @NotNull String __typename() {
      return this.__typename;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public ResponseFieldMarshaller marshaller() {
      return new ResponseFieldMarshaller() {
        @Override
        public void marshal(ResponseWriter writer) {
          writer.writeString($responseFields[0], __typename);
        }
      };
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "AsSearchResult{"
          + "__typename=" + __typename
          + "}";
      }
      return $toString;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof AsSearchResult) {
        AsSearchResult that = (AsSearchResult) o;
        return this.__typename.equals(that.__typename);
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int h = 1;
        h *= 1000003;
        h ^= __typename.hashCode();
        $hashCode = h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    public static final class Mapper implements ResponseFieldMapper<AsSearchResult> {
      @Override
      public AsSearchResult map(ResponseReader reader) {
        final String __typename = reader.readString($responseFields[0]);
        return new AsSearchResult(__typename);
      }
    }
  }
}
